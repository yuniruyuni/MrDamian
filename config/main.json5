{
  pipeline: [
    {
      // typeはcomponentの種類を指定するフィールド
      type: "non-exist-component",

      // typeにjexpr構文がきた場合はエラーになる。
      // type: "$ value", // つまりこれはエラーになる

      // nameはコンポネントのインスタンスの名称で、
      // パイプライン全体を通して同じnameを持つcomponentは
      // すべて内部データを共有している。
      // また出力データ(=Environment)のキーとしても使われる。
      // nameにはjexpr構文を使うことができない。
      name: "main",

      // whenはコンポネントの実行条件を指定するフィールドで、
      // jexpr構文が常に適用される。そのため $ を指定する必要がない。
      // しかしこの条件に関係なくinit()は実行されるので初期化は常に可能。
      when: "condition && condition2",

      // argsはコンポネントの実行時に渡る引数のオブジェクトで、
      // このオブジェクトの中身はjexpr構文が適用される。
      args: {
        // つまりこのように書いた場合、valueの中身が展開される。
        key: "$ value",
        recursive: {
          // このように子ノードで書いた場合もvalueが展開される。
          key: "$ value",
          // jexpr構文なのでもちろん比較演算等も行うことができる
          less: "$ value < 10",
          // 文字列の結合や(システムで登録された)関数の適用なども行うことができる。
          concat: "$ format('{}: {}', value1, value2)",
        },
      },
    },
    // twitchコンポネント例
    {
      type: "twitch",

      // twitchコンポネントの場合
      // actionがないならコンポネントの初期化
      // "init"や""でも初期化。
      // "send"など別の名称ならそのアクションを実行する。
      // こういうふうに共通nameだとインスタンスが共通になるという性質をつかって
      // ログインセッションなどの情報を複数のパイプライン内の処理で使い回すことができる。
      // action: "init",

      // { twitch: { main: (ここ) }} に値がアサインされる。
      // 指定がなかったら { twitch: ここ } にアサインされる。
      name: "main",

      // client_idは組み込みの値があるので省略して構わない。
      // ただユーザがどうしてもMrDamianを自前で作りたい場合のために
      // 組み込んだものとは違うclient_idを指定できるようにするかな要検討。
      // "client_id": "'xxxxxxxxxx'",

      // channelは配信者のチャンネル名。
      channel: "yuniruyuni"
    },
    // youtubeコンポネント例
    {
      // 多分twitchと使い心地は同じ感じにできる。
      // APIは https://developers.google.com/youtube/v3/live/docs?hl=ja が使える
      // OAuthのdevice code grant flowも存在する: https://developers.google.com/identity/protocols/oauth2/native-app?hl=ja
      type: "youtube",
      // actionがないならコンポネントの初期化

      // nameでインスタンスをmain二設定
      name: "main",

      // channelは配信者のチャンネル名。
      channel: "yuniruyuni"
    },
    // deeplコンポネント
    {
      type: "deepl",
      // actionがないのでこれもセッション初期化。
      apikey: "DEEPL_API_KEY", // TODO: ここに値を書かせるかどうか...結構悩ましい
    },
    {
      type: "panel",
      forms: [
        {
          // トグルボタン。
          // ON/OFFに応じて、ここに入ってきたイベントに
          // nameで与えたフィールドがtrue/falseで追加される。
          // この場合は panel.auto_shoutout に true や false が入る
          type: "toggle",
          // ここだけの強い制約としてnameはtypeによらず一意である必要がある。
          name: "auto_shoutout",
          text: "Auto shoutout"
        },
        {
          // ボタン。この設定値の場合クリックごとに
          // panel.shoutout = true
          // という値を持ったイベントが発火
          type: "button",
          name: "shoutout",
          text: "Send shoutout"
        },
        {
          type: "group",
          name: "message",
          forms: [
            {
              // テキストラベル
              // ユーザ画面上にテキストを表示する
              type: "label",
              name: "latest",
              // とりあえずのデフォルト値を設定しておく
              // この値は後でargsで上書きできるが、そのときはjexpr構文が使える
              text: "",
            },
            {
              type: "label",
              name: "count",
              text: "",
            },
          ],
        },
      ],
      // panelのinitialize action(defaultアクション)ではargsを受け取らない。
      // これによってjexpr構文を使えないことを強制する
    },
    {
      when: "twitch.main.message",
      type: "panel",
      // updateアクションを使うとstatus値をpipeline側から強制更新できる
      // この場合はtwitchメッセージを受信した時に
      // panelコンポネントのlatest_messageを更新するという寸法。
      // パネルを動的に追加/削除することはできないという点には注意。
      // (そういうことをしたいなら新しいコンポネントプラグインを作る想定)
      action: "update",
      args: {
        // この名称指定もグループについて考慮する必要があった。
        // 簡易に記述できるドット区切りで指定するのか、
        // それとも様々な文字列の指定が可能な配列で指定するのかで悩んだ。
        // nameはそもそもjexprの制約もありドット区切りできるような文字列しか使えない
        // そこで利用者の利便性を考慮するとドット区切りが望ましいと判断。
        name: "message.latest",
        // このようにjexprの展開した結果でcomponentの値を更新することができる
        text: "$ format('{}: {}', message.name, message.text)"
      },
    },
    {
      when: "hoge",
      type: "panel",
      action: "update",
      args: {
        // ここにtypeとかあるならjexprの展開を許すことになるが
        // これで選べるのはすでにcomponentsとして刺さっているものだけなので
        // 該当するものがない場合は単に更新操作が無視される
        // type: "$ hoge",
        name: "hoge_component",
        // 引数が噛み合わなくなるのを回避できない
        // が、それはユーザの勝手に任せることにした。
        // コンポネントの実装に応じて実行時エラーになったり無視されるだろう。
        hoge: "hogehoge",
      },
    },
    {
      when: "twitch.main.message",
      // 実行ごとにカウントアップするだけのコンポネント
      // しかしwhenと組み合わせてメッセージ受信数をカウントするのに使えるという寸法
      type: "count",
      name: "message",
    },
    {
      type: "panel",
      action: "update",
      args: {
        name: "message.count",
        text: "$ format('total: {}', count)",
      },
    },
    {
      // 定期的にイベントを発行するコンポネント
      // Componentの一般論として(type).(name) に trueが入るのだが
      // この場合はnameを持たないので、単に periodic に true が入る。
      type: "periodic",
      // その実行時間。ミリ秒単位。この場合3分。
      "interval": 180000,
    },
    {
      // 上記のようなperiodicの値が登録されるため
      // periodicイベントを受けて定期的なメッセージを送信するには
      // 単にperiodicと書けばよいことになる
      when: "periodic",
      // TODO: panel.shoutoutとかpanel.auto_shoutoutが実現したら
      //       以下のwhenを有効にしたサンプルに変えたい
      // when: "$ panel.shoutout || (panel.auto_shoutout && periodic)",

      // 同じtwitchコンポネントのmainインスタンスなのだけれど
      type: "twitch",
      name: "main",

      // actionとしてsendを指定すると、
      // 同じインスタンスの接続を使ってメッセージ送信を行える
      action: "send",

      args: {
        // この部分はもちろんargsなのでjexprが使える(今回はただの定数)
        message: "Discordチャンネルもあります！チャンネルポイント交換から！"
      },
    },
    {
      when: "twitch.main.message",
      // Submoduleコンポネントはサブモジュールを呼び出すために使える
      type: "submodule",
      // ターゲットのサブモジュールの入ったjson5名を指定する
      path: "auto_translator.json5",
      // サブモジュールに対して接続するコンポネントインスタンスを指定できる
      // 何も指定していない場合はデフォルトのインスタンスが使われる
      // つまり基本的にmain側ではこれを指定する必要はないという形だけど
      // たまに複数のインスタンスをつかいたかったりmain側で色々とインスタンスを使っている場合は
      // ここの指定が必要になる……という仕組み。
      inherit: {
        "main": "main",
        // ここもjexprを使って外部側で動的に名称が指定されても
        // 式を評価せずにただの文字列としてとりあつかう。
        // つまり以下のような式を使っても評価されない。
        // "main": "$ twitch.main.message.channel",
      },
      // サブモジュール側のparamsで設定されている変数に
      // argsの内容が展開される。
      // paramsにないものは消える。
      args: {
        message: "$ twitch.main.message.message",
      }
    },
    {
      when: "twitch.main.message",
      type: "submodule",
      path: "logger.json5",
      args: {
        dir: "./log/twitch/",
        output: {
          channel: "$ twitch.main.message.channel",
          user: "$ twitch.main.message.user",
          message: "$ twitch.main.message.message",
        },
      },
    },
  ]
}
